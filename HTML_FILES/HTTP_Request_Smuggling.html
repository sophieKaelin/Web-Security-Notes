<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>HTTP Request Smuggling</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>HTTP Request Smuggling</h1><br/><strong>What is it?</strong><br />• Interfere with way site processes sequence of HTTP requests recieved from 1+ users<br />• Criticals vulnerabilities<br /><strong><br />What happens?</strong><br />• Current web apps chain HTTP servers between users and app logic<br />• User sends request to front-end server (load balancer/reverse proxy)<br />• Front-end server forwards request to 1+ back-end servers.<br />• Often used in modern cloud-based apps<br />• Send several requests over same back-end network connection<br />   ◇ Efficiency ++<br />• Parses HTTP request headers to determine start and end of each.<br />• Must agree on boundaries between requests<br />• ATTACK:<br />   ◇ cause part of front-end request to be interpreted by back-end as start of next request.<br /><strong><br />How vulnerabilities arise</strong><br />• Two ways to specify where request ends:<br />   ◇ Content-Length, Transfer-Encoding<br />   ◇ Transfer-Encoding can be “chunked” : message body contains chunks of data, newlines between each.<br />   ◇ Transfer-Encoding sees 0 length of chunk to mean end of request<br />• Use both methods at once to conflict each other.<br />   ◇ If both headers used, ignore Content-Length header<br />• Some servers don&#39;t support transfer-encoding header<br />   ◇ can be induced not to process if the header is obfuscated.<br />• If front and back end server behave differently with the TE header, they could disagree on boundaries between requests.<br />   ◇ THIS IS THE VULN</div></body></html>