<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Exploiting Implementation Flaws</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>Exploiting Implementation Flaws</h1><br/><strong>Cache key flaws</strong><br />• Most websites take input from URL path and query string<br />   ◇ these are usually keyed<br />   ◇ use these as our cache buster<br />• Sometimes different caching systems will:<br />   ◇ exclude query string<br />   ◇ filter our specific query params<br />   ◇ normalise input in keyed components.<br /><br /><strong>Cache probing methodology</strong><br />• differs a little from poisoning<br />• varys dramatically depending on configuration<br />• 3 steps<br /><br /><span style="text-decoration:underline;">Identify suitable cache oracle</span><br />• for testing<br />• a page/endpoint that provides feedback on cache behaviour<br />   ◇ HTTP header that tells you whether you got a cache hit or not<br />   ◇ Observable changes to dynamic content<br />   ◇ Distinct response times<br />• Reflect the entire URL and 1+ query parameters in response<br />• If you can find a specific third-party cache that is being used, consult the documentation<br />   ◇ May have info on how default key is constructed.<br /><br /><span style="text-decoration:underline;">Probe key handling</span><br />• Work out if cache does any additional processing of your input when generating a key<br />• Look for any transformations<br />• Exclusions: query parameters or query string, removing/adding the port?<br />• If you have access to cache key<br />   ◇ just compare the key after injecting different inputs<br /><br /><span style="text-decoration:underline;">Identify exploitable gadget</span><br />• Find gadget to chain with cache key flaw<br />• Severity of attack dependent on the gadget you are able to exploit<br />• Gadgets are often classic client-side vulns (xss, open redirects)<br /><strong><br />Exploiting cache key flaws</strong><br />• Chuck a &#39;/&gt;&lt;script&gt;alert(1)&lt;/script&gt; and see what happens.<br /><br /><span style="text-decoration:underline;">Unkeyed port</span><br />• Host is often keyed (usually unlikely candidate for injection)<br />• Some systems parse the header to exclude the port<br />• Sample attack<br />   ◇ DDOS: Cache a dud port, so everyone is redirected to something that doesn&#39;t work until it expires.<br />   ◇ XXS: if site allows non-numeric ports<br /><br /><span style="text-decoration:underline;">Unkeyed query string</span><br />• Detection<br />   ◇ Hard to do if the response doesn&#39;t give you a hit or miss response.<br />   ◇ See how changing a parameter value has an effect on the response<br />   ◇ Cache buster wont work: add it as a keyed header that wont interfere with applications behaviour.<br />• Exploitation<br />   ◇ exclude query string from cache key = more severe attack<br />   ◇ try using the header: Pragma: x-get-cache-key<br />• Just add a parameter and see if it&#39;s unkeyed<br />   ◇ Maybe it&#39;s reflected?<br />• Add a new header, and see if it&#39;s keyed (by changing the value)<br /><br /><span style="text-decoration:underline;">Unkeyed query parameters</span><br />• Sometimes it&#39;s only specific query parameters, and not the whole string.<br />   ◇ Often the ones that are not relevant to back-end application (analytics or targetted advertisments)<br />• UTM parameters are a good one to check<br />   ◇ utm_content<br />• Unlikely to have significant impact on response<br /><br /><span style="text-decoration:underline;">Cache parameter cloaking</span><br />• Work out how the cache parses the URl to identify/remove unwanted params<br />• Might be able to sneak some params in by cloacking them in an excluded param<br />• e.g: <code>GET /?example=123?excluded_param=bad-stuff-here</code><br />   ◇ If second param not recognised then example = the whole payload, including the ? (sneak in some xss or something)<br />   	<span style="text-decoration:underline;">Exploiting Param parsing quirks</span><br />   ◇ Issues arise when back-end identifies parameters the cache does not (different delimiters &amp; and ;)<br />   ◇ Especially powerful exploit if it gives you control over a function that will be executed. (callback function)<br />    <span style="text-decoration:underline;">Exploiting fat GET support</span><br />   ◇ If HTTP method not keyed, poison with POST request <br />   ◇ RARE<br />   ◇ Even try adding a body to a GET request<br />   ◇ add X-HTTP-Method-Override: POST to a get request.<br />    <span style="text-decoration:underline;">Exploiting dynamic content in resource imports</span><br />   ◇ Usually static, but can reflect input from the query string<br /><br /><span style="text-decoration:underline;">Normalised cache keys</span><br />• <br /><br /><span style="text-decoration:underline;">Cache key injection</span><br /><br /><span style="text-decoration:underline;">Internal cache</span></div></body></html>