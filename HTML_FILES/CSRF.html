<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>CSRF</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>CSRF</h1><br/><span style="text-decoration:underline;">Jamie&#39;s TLDR</span><br />Yeah pretty much! So CSRF is essentially forcing a user to do something they didn’t want to do by taking advantage of the fact that your browser automatically sends cookies for particular domains when it sends a request. Attackers can take advantage of that by crafting a request (for example a password change request on a banking site) and hide it in their own website. If they can phish a user into visiting their site, they can fire off that password change request, and the users browser will automatically send their session cookies with it, to validate the request.<br /><br />Tokens come into play as a preventative measure. Tokens are generally used as a way of validating that a request is unique, and hasn’t been sent to the server before<br /><br />In that example they’re saying that sometimes you can check if the referer for a request is correct for the site that sent it, however that’s not a valid method of preventing CSRF because the referrer header is user controlled, meaning that it can be changed to whatever you want, or even left out entirely, so it doesn’t stop an attacker changing or deleting the header, then sending the request<br /><br /><strong>Overview</strong><br />• Allows attacker to induce users to perform unintended actions<br />• partly circumvent same origin policy<br />• CSRF = Cross Site Request Forgery<br />• refreshes each time.<br />• Wont work on JSON requests.<br />• You can only do CSRF attack with POST request, not PUT<br /><br /><strong>How it Works</strong><br />• Three key conditions in order for CSRF attack to be possible:<br />   ◇ <span style="text-decoration:underline;">A Relevant Action</span>: action within app attacker has reason to induce (e.g. modifying permissions, changing a password)<br />   ◇ <span style="text-decoration:underline;">Cookie-based session handling</span>: Involves issues 1+ HTTP requests. Relies on session cookies to identify user who made the requests<br />   ◇ <span style="text-decoration:underline;">No unpredictable request parameters</span>: Request performing action doesn&#39;t contain parameters that can&#39;t be guessed by attacker (e.g. if changing a password and need to know existing password, won&#39;t work)<br />• SAMPLE HTML:<br /><code>&lt;html&gt;<br />	&lt;body&gt;<br />		&lt;form action=&quot;https://vulnerable-website.com/email/change&quot; method=&quot;POST&quot;&gt;<br />			&lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;pwned@evil-user.net&quot; /&gt;<br />    &lt;/form&gt;<br />    &lt;script&gt;<br />    	document.forms[0].submit();<br />    &lt;/script&gt;<br />	&lt;/body&gt;<br />&lt;/html&gt;</code><br /><br /><strong>Constructing Attack</strong><br />• You can create your own dodgy html, but this can take a while.<br />• Luckily, Burp has a CSRF PoC generator<br />   ◇ Right click request -&gt; engagement tools/ generate CSRF PoC<br />   ◇ Burp will generate HTML to trigger request<br />   ◇ You can adjust the code if you need to.<br /><strong><br />Delivering exploit</strong><br />• Similar delivery for reflected XSS<br />• attacker place malicious HTMl on site they control, and induce victims to visit the site<br />• Wait for user to visit the site<br />• Some simple exploits use GET method in a single URL on vulnerable site<br /><code>&lt;img src=&quot;https://vulnerable-website.com/email/change?email=pwned@evil-user.net&quot;&gt;</code><br /><strong><br />Prevention</strong><br />• Include CSRF tokens in relevant requests<br />• SameSite cookies are also a good way of protecting against attacks.<br /><br /></div></body></html>