## Exploiting Implementation Flaws
Cache key flaws
* Most websites take input from URL path and query string
   	* these are usually keyed
   	* use these as our cache buster
* Sometimes different caching systems will:
   	* exclude query string
   	* filter our specific query params
   	* normalise input in keyed components.

Cache probing methodology
* differs a little from poisoning
* varys dramatically depending on configuration
* 3 steps

Identify suitable cache oracle
* for testing
* a page/endpoint that provides feedback on cache behaviour
   	* HTTP header that tells you whether you got a cache hit or not
   	* Observable changes to dynamic content
   	* Distinct response times
* Reflect the entire URL and 1+ query parameters in response
* If you can find a specific third-party cache that is being used, consult the documentation
   	* May have info on how default key is constructed.

Probe key handling
* Work out if cache does any additional processing of your input when generating a key
* Look for any transformations
* Exclusions: query parameters or query string, removing/adding the port?
* If you have access to cache key
   	* just compare the key after injecting different inputs

Identify exploitable gadget
* Find gadget to chain with cache key flaw
* Severity of attack dependent on the gadget you are able to exploit
* Gadgets are often classic client-side vulns (xss, open redirects)

Exploiting cache key flaws
* Chuck a '/><script>alert(1)</script> and see what happens.

Unkeyed port
* Host is often keyed (usually unlikely candidate for injection)
* Some systems parse the header to exclude the port
* Sample attack
   	* DDOS: Cache a dud port, so everyone is redirected to something that doesn't work until it expires.
   	* XXS: if site allows non-numeric ports

Unkeyed query string
* Detection
   	* Hard to do if the response doesn't give you a hit or miss response.
   	* See how changing a parameter value has an effect on the response
   	* Cache buster wont work: add it as a keyed header that wont interfere with applications behaviour.
* Exploitation
   	* exclude query string from cache key = more severe attack
   	* try using the header: Pragma: x-get-cache-key
* Just add a parameter and see if it's unkeyed
   	* Maybe it's reflected?
* Add a new header, and see if it's keyed (by changing the value)

Unkeyed query parameters
* Sometimes it's only specific query parameters, and not the whole string.
   	* Often the ones that are not relevant to back-end application (analytics or targetted advertisments)
* UTM parameters are a good one to check
   	* utm_content
* Unlikely to have significant impact on response

Cache parameter cloaking
* Work out how the cache parses the URl to identify/remove unwanted params
* Might be able to sneak some params in by cloacking them in an excluded param
* e.g: GET /?example=123?excluded_param=bad-stuff-here
   	* If second param not recognised then example = the whole payload, including the ? (sneak in some xss or something)
   	Exploiting Param parsing quirks
   	* Issues arise when back-end identifies parameters the cache does not (different delimiters & and ;)
   	* Especially powerful exploit if it gives you control over a function that will be executed. (callback function)
    Exploiting fat GET support
   	* If HTTP method not keyed, poison with POST request 
   	* RARE
   	* Even try adding a body to a GET request
   	* add X-HTTP-Method-Override: POST to a get request.
    Exploiting dynamic content in resource imports
   	* Usually static, but can reflect input from the query string

Normalised cache keys
* 

Cache key injection

Internal cache

